# Copied from chromium's build/toolchain and modified for goma.
#
# Copyright 2015 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Toolchain-related configuration that may be needed outside the context of the
# toolchain() rules themselves.

declare_args() {
  # Enable Link Time Optimization in optimized builds (output programs run
  # faster, but linking is up to 5-20x slower).
  # Note: use target_os == "linux" rather than is_linux so that it does not
  # apply to host_toolchain when target_os="android".
  allow_posix_link_time_opt = target_os == "linux" && target_cpu == "x64"

  # Set to true to use lld, the LLVM linker. This flag may be used on Windows
  # with the shipped LLVM toolchain.
  #
  # It turned out gomacc linked with lld does not work on chromeos sandbox.
  # So, don't make it enabled by default without confirming it works.
  # See crbug.com/780045
  use_lld = os == "win" && host_os != "win"

  # If used with allow_posix_link_time_opt, it enables the experimental support
  # of ThinLTO that links 3x-10x faster but (as of now) does not have all the
  # important optimizations such us devirtualization implemented. See also
  # http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html
  use_thin_lto = false

  # If this is set to true, or if LLVM_FORCE_HEAD_REVISION is set to 1
  # in the environment, we use the revision in the llvm repo to determine
  # the CLANG_REVISION to use, instead of the version hard-coded into
  # //tools/clang/scripts/update.py. This should only be used in
  # conjunction with setting LLVM_FORCE_HEAD_REVISION in the
  # environment when `gclient runhooks` is run as well.
  llvm_force_head_revision = false
}

declare_args() {
  if (is_clang) {
    # Clang compiler version. Clang files are placed at version-dependent paths.
    clang_version = "7.0.0"
  }
}

# Subdirectory within root_out_dir for shared library files.
# TODO: GYP sets this to "lib" for Linux & Android, but this won't work
#     in GN until support for loadable_module() is added.
#     See: https://codereview.chromium.org/1236503002/
shlib_subdir = "."

# Root out dir for shared library files.
root_shlib_dir = root_out_dir
if (shlib_subdir != ".") {
  root_shlib_dir += "/$shlib_subdir"
}

# Extension for shared library files (including leading dot).
if (os == "mac") {
  shlib_extension = ".dylib"
} else if (is_posix) {
  shlib_extension = ".so"
} else if (os == "win") {
  shlib_extension = ".dll"
} else {
  assert(false, "Platform not supported")
}

# Prefix for shared library files.
if (is_posix) {
  shlib_prefix = "lib"
} else {
  shlib_prefix = ""
}

# While other "tool"s in a toolchain are specific to the target of that
# toolchain, the "stamp" and "copy" tools are really generic to the host;
# but each toolchain must define them separately.  GN doesn't allow a
# template instantiation inside a toolchain definition, so some boilerplate
# has to be repeated in each toolchain to define these two tools.  These
# four variables reduce the duplication in that boilerplate.
stamp_description = "STAMP {{output}}"
copy_description = "COPY {{source}} {{output}}"
if (host_os == "win") {
  _tool_wrapper_path =
      rebase_path("//build/toolchain/win/tool_wrapper.py", root_build_dir)

  stamp_command = "$python_path $_tool_wrapper_path stamp {{output}}"
  copy_command =
      "$python_path $_tool_wrapper_path recursive-mirror {{source}} {{output}}"
} else {
  stamp_command = "touch {{output}}"
  copy_command = "ln -f {{source}} {{output}} 2>/dev/null || (rm -rf {{output}} && cp -af {{source}} {{output}})"
}
