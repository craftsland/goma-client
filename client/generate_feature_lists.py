#!/usr/bin/python3
#
# Copyright 2012 The Goma Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Generates the lists of clangs features.

See: http://clang.llvm.org/docs/LanguageExtensions.html#feature-checking-macros
"""

# TODO: make this work with the latest clang code.
#                    Currently, the script cannot get some fields.



import argparse
import datetime
import re
import urllib.request, urllib.error, urllib.parse

# TODO: the entire script should be wrapped in main()
parser = argparse.ArgumentParser(description='Tool to re-gen clang_features.cc')
parser.add_argument(
    '-r',
    '--revision',
    type=int,
    default=-1,
    help=('LLVM revision to read in order to generate the '
          'features. If unspecified, the default behavior is to '
          'read the latest revision available in trunk.'))
args = parser.parse_args()

BASE_URL = 'http://llvm.org/svn/llvm-project/cfe/trunk'
GENERATE_AT_REVISION = None if args.revision == -1 else args.revision


def GenerateUrl(path):
  rev_suffix = ('' if GENERATE_AT_REVISION is None else
                '/?p=%s' % GENERATE_AT_REVISION)
  return BASE_URL + path + rev_suffix


ATTR_URL = GenerateUrl('/include/clang/Basic/Attr.td')
PPMACRO_EXPANSION_URL = GenerateUrl('/lib/Lex/PPMacroExpansion.cpp')
BUILTINS_URL = GenerateUrl('/include/clang/Basic/Builtins.def')
FEATURES_URL = GenerateUrl('/include/clang/Basic/Features.def')
# TODO: There may be a better way to obtain all the diagnostic flags.
# This reference mentions that it is generated by `clang-tblgen -gen-diag-docs`.
# Unfortunately I couldn't find the input to `clang-tblgen`.
DIAGNOSTICS_URL = GenerateUrl('/docs/DiagnosticsReference.rst')

CASE_NAME_PATTERN = re.compile(r'Case\("(.*?)"')
ATTR_NAME_IN_BRACKETS_PATTERN = re.compile(r'(.*?)<"(.*?)">')
CPP_ATTR_NAME_IN_BRACKETS_PATTERN = re.compile(
    r'CXX11<"(.*?)",\s*"(.*?)"(.*?)>')
DECLSPEC_NAME_IN_BRACKETS_PATTERN = re.compile(r'Declspec<"(.*?)">')
SPELLINGS_PATTERN = re.compile(r'let Spellings = \[(.*?)\];',
                               re.MULTILINE | re.DOTALL)
BUILTINS_PATTERN = re.compile(r'^[A-Z_]*BUILTIN\((\w+),', re.MULTILINE)
FEATURE_PATTERN = re.compile(r'^FEATURE\((\w+),', re.MULTILINE)
EXTENSION_PATTERN = re.compile(r'^EXTENSION\((\w+),', re.MULTILINE)
# Example diagonistic (warning) flags:
# -Wall
# -W#warnings
# -Watomic-alighment
# -Wc++11-compat
# -Wstrict-overflow=1
# ...
# Note: I couldn't spot a single diagnostic flag containing '_'.
DIAGNOSTIC_PATTERN = re.compile(r'^(-W[a-zA-Z0-9+#=\-]+)$', re.MULTILINE)


class Error(Exception):
  pass


def GetRevision():
  if GENERATE_AT_REVISION is not None:
    return str(GENERATE_AT_REVISION)
  trunk = urllib.request.urlopen(BASE_URL).read().decode('utf-8')
  matched = re.search(r'Revision (\d+):', trunk)
  if matched:
    return matched.group(1)
  raise Error('Failed to parse revision.')


def ScrapeFunction(source, function_name):
  m = re.search(function_name + r'.*{', source)
  if not m:
    raise Error(function_name + ' not found')

  s = source[m.end():]
  m = re.search('\n}', s)
  if not m:
    raise Error(function_name + ' doesn\'t end')

  return s[:m.start()]


# Fetch all required data.
revision = GetRevision()
ppmacro_expansion = urllib.request.urlopen(
    PPMACRO_EXPANSION_URL).read().decode('utf-8')
attr_td = urllib.request.urlopen(ATTR_URL).read().decode('utf-8')
builtins_def = urllib.request.urlopen(BUILTINS_URL).read().decode('utf-8')
features_def = urllib.request.urlopen(FEATURES_URL).read().decode('utf-8')
diagnostics_def = urllib.request.urlopen(DIAGNOSTICS_URL).read().decode('utf-8')

print('// Copyright %d Google Inc. All Rights Reserved.' %
      datetime.date.today().year)
print('// This is auto-generated file from generate_feature_list.py.')
print('// Clang revision: %s.' % revision)
print('// *** DO NOT EDIT ***')
print()
print('#include "absl/base/macros.h"')

# __has_feature
features = list(set(re.findall(FEATURE_PATTERN, features_def)))
features.sort()
print()
print('static const char* KNOWN_FEATURES[] = {')
for feature in features:
  print('    "%s",' % feature)
print('};')
print('static const unsigned long NUM_KNOWN_FEATURES =')
print('    ABSL_ARRAYSIZE(KNOWN_FEATURES);')

# __has_extension
extensions = list(set(re.findall(EXTENSION_PATTERN, features_def)))
extensions.sort()
print()
print('static const char* KNOWN_EXTENSIONS[] = {')
for extension in extensions:
  print('    "%s",' % extension)
print('};')
print('static const unsigned long NUM_KNOWN_EXTENSIONS =')
print('    ABSL_ARRAYSIZE(KNOWN_EXTENSIONS);')

# __has_attribute
attributes = set()
for spellings in re.findall(SPELLINGS_PATTERN, attr_td):
  for entry in ATTR_NAME_IN_BRACKETS_PATTERN.findall(spellings):
    if entry[0] == "Pragma":
      # Ignore attribute used with pragma.
      # Pragma seems to be only used for #pragma.
      # It also caused the issue. (b/63365915)
      continue
    attr = entry[1]
    if '"' in attr:
      l = attr.split('"')
      attr = l[len(l) - 1]
    if attr and not attr in attributes:
      attributes.add(attr)
attributes = list(attributes)
attributes.sort()
print()
print('static const char* KNOWN_ATTRIBUTES[] = {')
print('\n'.join(['    "%s",' % attr for attr in attributes]))
print('};')
print('static const unsigned long NUM_KNOWN_ATTRIBUTES =')
print('    ABSL_ARRAYSIZE(KNOWN_ATTRIBUTES);')

# __has_cpp_attribute
# CXX11<"clang", "fallthrough", 1>  --> clang::fallthrough
# CXX11<"", "noreturn">             --> noreturn
cpp_attributes = set()
for spellings in re.findall(SPELLINGS_PATTERN, attr_td):
  for attr in CPP_ATTR_NAME_IN_BRACKETS_PATTERN.findall(spellings):
    namespace = attr[0]
    name = attr[1]
    if namespace:
      cpp_attributes.add(namespace + '::' + name)
    else:
      cpp_attributes.add(name)
cpp_attributes = list(cpp_attributes)
cpp_attributes.sort()
print()
print('static const char* KNOWN_CPP_ATTRIBUTES[] = {')
print('\n'.join(['    "%s",' % attr for attr in cpp_attributes]))
print('};')
print('static const unsigned long NUM_KNOWN_CPP_ATTRIBUTES =')
print('    ABSL_ARRAYSIZE(KNOWN_CPP_ATTRIBUTES);')

# __has_declspec_attribute
declspec_attributes = set()
for spellings in re.findall(SPELLINGS_PATTERN, attr_td):
  for attr in DECLSPEC_NAME_IN_BRACKETS_PATTERN.findall(spellings):
    declspec_attributes.add(attr)
declspec_attributes = list(declspec_attributes)
declspec_attributes.sort()
print()
print('static const char* KNOWN_DECLSPEC_ATTRIBUTES[] = {')
print('\n'.join(['    "%s",' % attr for attr in attributes]))
print('};')
print('static const unsigned long NUM_KNOWN_DECLSPEC_ATTRIBUTES =')
print('    ABSL_ARRAYSIZE(KNOWN_DECLSPEC_ATTRIBUTES);')

# __has_builtin
builtins = list(set(re.findall(BUILTINS_PATTERN, builtins_def)))
builtins.sort()
print()
print('static const char* KNOWN_BUILTINS[] = {')
print('\n'.join(['    "%s",' % builtin for builtin in builtins]))
print('};')
print('static const unsigned long NUM_KNOWN_BUILTINS =')
print('    ABSL_ARRAYSIZE(KNOWN_BUILTINS);')

# __has_warning
diagnostics = list(set(re.findall(DIAGNOSTIC_PATTERN, diagnostics_def)))
diagnostics.sort()
print()
print('static const char* KNOWN_WARNINGS[] = {')
print('\n'.join(['    "%s",' % d for d in diagnostics]))
print('};')
print('static const unsigned long NUM_KNOWN_WARNINGS =')
print('    ABSL_ARRAYSIZE(KNOWN_WARNINGS);')
